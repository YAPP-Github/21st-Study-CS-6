# BBST

### 목차

### 이진트리(Binary Tree)란

- 노드가 최대 2개의 자식 노드를 가지는 트리 자료구조
- 노드의 자식노드는 왼쪽 자식 노드(left child node)와 오른쪽 자식 노드(right child node)로 구성

### BST(Binary Search Tree)란

- 이진 트리 구조를 가진 이진 탐색 트리는 임의의 키를 가진 원소를 삽입, 삭제, 검색하는데 효율적인 자료 구조
- 이진 탐색 트리의 정의
    - 이진 탐색 트리는 이진 트리로써 공백이 아니면 아래의 성질을 만족한다
    - 모든 원소는 상이한 키를 갖는다
    - 왼쪽 서브트리에 있는 원소의 키는 그 루트의 키보다 작다
    - 오른쪽 서브트리에 있는 원소의 키는 그 루트의 키보다 크다
    - 왼쪽 서브트리와 오른쪽 서브트리도 모두 이진 탐색 트리이다   
      <img src="https://user-images.githubusercontent.com/69676101/210787267-0187d5ee-b9d0-49a2-8576-94a59b961396.png"  width="400">

- 이진 탐색 트리에서 중위순회는 정렬된 형태로 출력된다
- 연결리스트의 경우 자료 입력, 삭제에 필요한 계산복잡성은 𝑂(1)로 효율적이지만 탐색하는 데에는 𝑂(𝑛)의 계산복잡성이 발생한다. 이진 탐색의 경우 탐색에 소요되는 시간복잡도는 𝑂(log𝑛)으로 빠르지만, 연결리스트에 이진탐색을 적용하려 할 경우 무작위 위치로의 점프가 어려워 불가능하다.  연결리스트와 이진탐색 두 마리 토끼를 잡아보자는 것이 이진탐색트리의 목적이다.
- 가장 왼쪽 leaf node는 트리의 최솟값, 가장 오른쪽 leaf node는 트리의 최댓값이다

### BST의 탐색
<img src="https://user-images.githubusercontent.com/69676101/210787303-47c199eb-911a-4676-a694-2cafc1300317.png"  width="400">

- 과정

    1. 루트 노드의 키와 찾고자 하는 값을 비교한다. 찾고자 하는 값이라면 탐색을 종료한다.

    2. 찾고자 하는 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리로 탐색을 진행한다.

    3. 찾고자 하는 값이 루트노드의 키보다 크다면 오른쪽 서브트리로 탐색을 진행한다.

- 위 트리에서 10을 탐색할 때 비교하는 값은 7→8→10 순서이다.
- 4를 탐색할 때는 7→3→5순서로 탐색하고, 5의 왼쪽 서브트리를 비교해야하는데 5는 트리의 leaf node이기 때문에 서브트리가 존재하지 않는다. 따라서 4는 트리에 존재하지 않는다.
- 이진탐색트리의 탐색 시간복잡도는 트리의 높이 h라 할 때, O(h)이다. 최악의경우 leaf node까지 탐색해야하기 때문이다. 이 때 h번 비교 연산을 수행한다.

### BST의 한계

- 이진 탐색트리의 탐색, 삽입, 삭제의 시간복잡도는 모두 O(h)이다. 트리의 높이에 의해 수행시간이 결정된다.   
  <img src="https://user-images.githubusercontent.com/69676101/210787337-962d3b81-871c-437d-9dac-00598da3c464.png"  width="400">

- 위 트리의 경우 노드의 수는 적은데 높이가 4나 된다. 균형이 안맞기 때문이다.
- 극단적으로 n개의 노드가 크기순으로 일렬로 늘어져 높이가 n이 되는 경우도 이진 탐색트리에 해당하기때문에, 탐색속도가 O(log n)인 이진탐색을 계승했다고 보기 어렵다. (편향 이진 탐색 트리)

### BBST(Balanced Binary Search Tree)란

- BST가 편향된 경우 높이가 점점 커지는 것을 막기 위해 나온 트리
- 노드의 삽입과 삭제가 일어나는 경우에 자동으로 그 높이를 작게 유지하도록 한다
- 따라서 아무리 빈번하게 노드를 추가하고 삭제해도 높이를 제약하는 특성이 있어 성능상 유리하다   
  <img src="https://user-images.githubusercontent.com/69676101/210787386-f27713d6-9f6e-416a-9c8d-6f224aaee6e4.png"  width="400">

- BBST의 종류에 따라 트리의 높이의 균형을 잡기위한 알고리즘이 각기 다르다.

### BBST의 종류

- 이진의 균형 탐색 트리
    - AVL 트리
        - 이진 탐색 트리에서 삽입/삭제 연산에, 균형을 잡는 회전을 전 노드에 대해서 재귀적으로 수행하는 과정을 추가하는 트리
        - 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다
        - 어떤 시점에서 높이 차이가 1보다 커지면 **회전**을 통해 균형을 잡는다
        - 높이를 log N으로 유지하기 때문에 삽입,검색,삭제의 시간복잡도는 O(log N)
        - AVL 트리에서는 각 노드가 Balance Factor(BF) 정보를 가지고 있다. BF 는 (왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이) 이다. 균형이 유지되고 있다면 BF 는 -1, 0, 1의 값을 가진다. 이 이상이 나오면 균형이 깨진 것으로 보고 회전한다.
    - Red Black 트리   
      <img src="https://user-images.githubusercontent.com/69676101/210787423-a3ca415b-7ef9-4b14-9a60-b2c4cf8faa2b.png"  width="400">

        - 조건

            1. 모든 노드는 빨간색 혹은 검은색이다.

            2. 루트 노드는 검은색이다.

            3. 모든 리프 노드(NIL)들은 검은색이다. (NIL : null leaf, 자료를 갖지 않고 트리의 끝을 나타내는 노드)

          4. 빨간색 노드의 자식은 검은색이다. == No Double Red(빨간색 노드가 연속으로 나올 수 없다)

            5. 모든 리프 노드에서 Black Depth는 같다. == 리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다

- 이진이 아닌 균형 검색 트리
    - B 트리
    - B+ 트리
    - B* 트리
    - 2-3-4 트리

### Red Black Tree가 균형을 유지하는 방법
<img src="https://user-images.githubusercontent.com/69676101/210787456-fddfd52a-f07e-4de2-aafb-297e9689ec8d.png"  width="400">

- 레드 블랙 트리에 새로운 노드를 삽입할 때 새로운 노드는 항상 빨간색으로 삽입한다
    - 이 경우 위의 4번 조건이 위배되는 상황이 발생할 수 있다.
    - 따라서 이러한 double red 문제를 해결하기 위해 2가지 전략을 사용한다   
      <img src="https://user-images.githubusercontent.com/69676101/210787503-30218ceb-bef9-432b-82cd-405570130bae.png"  width="400">

- 새로 삽입할 노드 **N**(New), 부모 노드 **P**(Parent), 조상 노드 **G**(Grand Parent), 삼촌 노드 **U**(Uncle)
- double red가 발생했을 떄
    - 삼촌 노드(U)가 검은색 → restructuring
    - 삼촌 노드(U)가 빨간색 → recoloring
- Restructuring
    - 순서

        1. 새로운 노드(N), 부모 노드(P), 조상 노드(G)를 오름차순으로 정렬한다.

        2. 셋 중 중간값을 부모로 만들고 나머지 둘을 자식으로 만든다.

        3. 새로 부모가 된 노드를 검은색으로 만들고 나머지 자식들을 빨간색으로 만든다.   
           <img src="https://user-images.githubusercontent.com/69676101/210787538-8648b0be-1161-425e-8525-8b5b5e4e2a26.png"  width="400">

- Recoloring
    - 순서

        1. 새로운 노드(N)의 부모(P)와 삼촌(U)을 검은색으로 바꾸고 조상(G)을 빨간색으로 바꾼다.   

      1-1. 조상(G)이 루트 노드라면 검은색으로 바꾼다.   
      <img src="https://user-images.githubusercontent.com/69676101/210787577-f1341d67-9a98-4c5f-a1b8-90bc9811fc9d.png"  width="400">

      1-2. 조상(G)을 빨간색으로 바꿨을 때 또다시 Double Red가 발생한다면 또다시 Restructuring 혹은 Recoloring을 진행해서 Double Red 문제가 발생하지 않을 때까지 반복한다.


### Red Black Tree의 주요 성질

1. 노드의 색상은 Red 혹은 Black이다.
2. 루트 노드의 색상은 무조건 Black이다.
3. 모든 리프 노드의 색상은 Black이다.
4. Red 노드의 자식은 모두 Black이다.
    - Red 노드가 루트에서 리프까지의 경로에 연속으로 등장할 수 없음을 의미한다.
5. 루트 노드에서 임의의 리프 노드에 이르는 경로에 존재하는 Black 노드의 수는 일정하다.
    - Red 노드 + Black 노드의 수는 다를 수 있다.
    - 5번 성질로 인해 최단, 최장 경로의 노드 수가 차이가 2배 이상 커지지 않는다.

### 2-3-4 Tree, AVL Tree보다 Red Black Tree가 많이 사용되는 이유

- AVL 트리는 balance를 엄격히 유지하기에 조회 속도는 빠르나 삽입/삭제 시 balancing 과정으로 인해 속도가 지연된다.
    - 따라서 조회가 빈번히 발생하는 DB에 사용된다
- Red-Black Tree는 AVL 트리보다는 balance를 조금 느슨하게 유지하여 적절한 조회 속도를 가져가되 빠른 삽입/삭제를 지원한다.
- AVL 트리는 BF 라는 int 값을 가지고 있어 메모리를 더 잡아먹는다. Red-Black 트리는 2가지 색상이므로 bit 같이 두 가지 값만 표현하면 된다. 이런 이유들로 Red Black Tree 가 많이 쓰이고 있다.
- red-black트리와 AVL트리의 시간 복잡도는 동일 (검색, 삽입, 삭제 모두 O(logN))