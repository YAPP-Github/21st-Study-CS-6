<img src="https://user-images.githubusercontent.com/69676101/204745070-1caabf52-745b-4fd2-90d7-086b8d18811d.png"  width="400">


- 프로세스 1번

    ```c
    Load X, R1
    Inc R1
    Store X, R1
    ```

- 프로세스 2번

    ```c
    Load X, R2
    Dec R2
    Store X, R2
    ```

- X값의 경우의 수
  1. 프로세스 1번이 모든 작업을 끝내고 프로세스 2번이 시작되면 결과적으로 **메모리의 X값은 2**
  2. 프로세스 1번이 메모리에서 X값을 로드 → 프로세스 2번이 메모리에서 X값을 로드 → 프로세스 1번이 R1 레지스터를 1만큼 증가 → 프로세스 2번이 R2 레지스터를 1만큼 감소 → 프로세스 1번이 R1의 값을 X에 저장 → 프로세스 2번이 R2값을 X에 저장 → 결과적으로 **메모리의 X값은 1**
  3. 프로세스 2번이 메모리에서 X값을 로드 → 프로세스 1번이 메모리에서 X값을 로드 → 프로세스 2번이 R1 레지스터를 1만큼 감소 → 프로세스 1번이 R2 레지스터를 1만큼 증가 → 프로세스 2번이 R2의 값을 X에 저장 → 프로세스 1번이 R1값을 X에 저장 → 결과적으로 **메모리의 X값은 3**

   **→ 결과값에 멱등성을 보장할 수 없음**   
  → 하나의 공유자원에 여러 프로세스들이 동시에 접근할 때, 프로세스들의 순서를 정해서 동기화가 잘 이루어져 공유 자원들의 일관성을 유지해야함

**Race Condition**
- race=경쟁. 두 프로세스(스레드)가 하나의 자원을 놓고 경쟁하는 상황
- 두 개 이상의 concurrent 한 프로세스, 쓰레드들이 공유된 자원에 접근을 할 때, 동기화 해결 과정없이 수행하는 상황
- 디버깅 시에는 문제점이 드러나지 않음 → 상용화되는 서비스일 시 큰 문제가됨!!!   

   
**임계 구역**

- 공유 자원이 접근되는 부분
- 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역
- 상호배제를 위한 동기화를 위해서는 세가지 원칙이 지켜져야 함
    - mutual exclusion : 한 프로세스가 임계구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없음
    - progress : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야함
    - bounded waiting(유한 대기) : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 함 (임계 구역에 들어오기 위해 무한정 대기해서는 안됨)

## 동기화 도구

### 뮤텍스 락

- **하나의 공유 자원**에 접근하는 프로세스를 상정한 방식
- 옷가게의 탈의실과 비슷한 개념.
    - 손님 : 프로세스
    - 탈의실 : 임계구역
    - 가림 천막 : 프로세스들이 공유하는 전역변수 lock
    - 임계 구역 잠그기 : acquire 함수
    - 임계 구역 잠금 해제 : release 함수
- acquire 함수
    - 프로세스가 임계구역에 진입하기 전 호출
    - 만약 임계 구역이 잠겨있다면(전역변수 lock) 임계 구역이 열릴때까지 임계구역을 반복적으로 확인(busy waiting), 임계구역이 열려있다면 임계구역을 잠금(lock을 true로 변경)
- release 함수
    - 임계 구역에서의 작업이 끝나고 호출
    - 임계구역을 열어주는 (lock을 false로 변경) 함수

```c
acquire() {
	while (lock == true){         /* 임계 구역이 잠겨있으면 */
		;                           /* 잠겨있는지 반복적으로 확인 */
	lock = true;                  /* 열렸다면 임계구역 잠금 */
}

release() {
	lock = false;                 /* 작업 끝나고 잠금 해제 */
}
```

- busy waiting
    - lock이 잠겨있는지 쉴새없이 반복적으로 확인함
    - 권한 획득을 위해 많은 CPU 자원을 낭비

### 세마포어 (counting semaphore에 중점)

- 뮤텍스 락과 비슷, 그러나 좀더 일반화된 방식
- 뮤텍스락은 하나의 공유자원에 대한 방식이라면 세마포어는 공유자원이 여러개인 상황에서도 적용 가능
- 예를 들어, 한 사무실에 여러대의 컴퓨터가 5개의 프린터를 공유하여 사용한다고 할때, 한 프린터가 사용될 때마다 공유자원은 1씩 감소하게됨.
    - 프린터의 갯수 : 세마포어 (S) (임계구역에 진입할 수 있는 프로세스의 갯수, 사용가능한 자원의 갯수, (전역변수))
    - 임계구역에 들어가도 좋은지, 기다려야하는지를 알려주는 wait함수
    - 임계구역 앞에서 기다리는 프로세스에 ‘들어가도 된다’는 신호를 주는 signal 함수

```c
/* 뮤텍스 락의 acquire(), release()와 비슷하게, 세마포어도 임계구역 진입 전후에 wait(), signal()을 호출 */

wait()
// 임계 구역
signal()
```

```c
wait() {
	while( S <= 0 ) // 임계 구역에 진입할 수 있는 프로세스 갯수가 0개 이하라면
		;             // 사용할 수 있는 자원이 있는지 반복적으로 확인
	S--;            // 임계 구역에 진입할 수 있는 프로세스 갯수가 1개 이상이면 S(세마포어)를 1 감소시키고 임계구역에 진입
}
```

```c
signal() {
	S++;            // 임계 구역에서의 작업을 마치고 S(세마포어)를 1만큼 증가
}
```

- 세 개의 프로세스 P1, P2, P3가 두개의 공유자원에 순서대로 접근한다면
    1. P1이 wait()를 호출. S는 2이므로 S를 1감소시키고 임계 구역 진입
    2. P2가 wait()를 호출. S는 1이므로 S를 1감소시키고 임계 구역 진입
    3. P3가 wait()를 호출. S는 0이므로 무한히 반복하여 S확인
    4. P1이 작업을 끝내고 signal()호출하여 S를 1만큼 증가
    5. P3가 S가 1임을 확인. S를 1 감소시키고 임계구역 진입

  → 문제점 : 뮤텍스 락과 마찬가지로 P3의 경우 busy waiting을 하게됨.

  → 해결점 : 세마포어는 더 좋은 방법을 사용!! **Block & WakeUp**

- wait()는 사용할 자원이 없는 경우 해당 프로세스의 상태를 대기상태로 만들고 그 프로세스의 PCB를 세마포어를 위한 대기 큐에 집어 넣음.
- 다른 프로세스가 임계구역에서 작업이 끝나고 signal()을 호출하면 signal()은 대기중인 프로세스를 대기 큐에서 제거, 프로세스 상태를 준비상태로 변경하여 준비 큐로 옮겨줌

    ```c
    wait() {
    	S--;
    	if(S < 0){
    		해당 프로세스 PCB를 대기 큐에 삽입
    		sleep();   // 대기 상태로 접어들음
    	}
    }
    ```

    ```c
    signal() {
    	S++;
    	if(S <= 0){
    		대기 큐에 있는 프로세스를 제거
    		wakeup(P);  // 프로세스 P를 대기 상태에서 준비 상태로 변경
    	}
    }
    ```

- Block & Wakeup 사용시
    1. 프로세스 P1이 wait()호출, S를 1만큼 감소, 임계 구역 진입 (S는 1)
    2. 프로세스 P2가 wait()호출, S를 1만큼 감소, 임계 구역 진입 (S는 0)
    3. 프로세스 P3가 wait()호출, wait()에 들어갈때 S를 1만큼 감소하므로 S는 -1이 되고, 해당 프로세스는 대기 큐에 삽입됨
    4. P1이 작업 종료, signal() 호출 → S가 1만큼 증가 → S는 0이므로 대기큐에있던 P3가 준비 큐로 옮겨짐
    5. 깨어난 P3가 임계구역 진입
    6. P2 작업 종료, signal()호출, S 1증가하여 S는 1이됨
    7. P3 작업 종료, signal()호출, S 1증가하여 S는 2가됨

<img src="https://user-images.githubusercontent.com/69676101/204745816-d7542645-2cd3-45da-acde-6c6c97033ded.png"  width="400">

### 의문점

- 공유자원은 갯수에 의존하지 않고 어떤 공유자원인지가 더 중요한 것 아닌지?
- 예를 들어 공유 자원이 x, y, i, j가 있다고 할 때 액세스 가능한 공유자원이 4개인지가 중요한게아니라, 내가 사용할 공유자원(ex, i를 사용해야할때)을 아무도 건들이지 않는 상태인지가 더 중요한게 아닌가?
- 공유자원이 4개라고 해서 아무데나 들어가서 자원을 사용하고 바꿔도 되는게 아닐텐데 .. 이해가 안간다
- [Process Synchronisation in OS - Scaler Topics](https://www.scaler.com/topics/operating-system/process-synchronization-in-os/)
  - Counting Semaphores can have any value and are not limited to a certain area. They can be used to restrict access to a resource that has a concurrent access limit. (카운팅 세마포어는 모든 값을 가질 수 있으며 특정 영역에 제한되지 않습니다. 동시 액세스 제한이 있는 리소스에 대한 액세스를 제한하는 데 사용할 수 있습니다.)
- 커넥션 풀과 비슷한 개념인가!!
- 동기화의 두가지 의미
    - 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 제어하는 것 (상호 배제를 위한 동기화)
    - 특정 조건이 만족되어야만 실행할 수 있는 상황에서 올바른 순서대로 실행하게 하는 것(실행 순서 제어를 위한 동기화)

*PCB : 운영체제가 프로세스에 대한 중요한 정보를 저장해놓을 수 있는 저장공간, 프로세스들의 context switching시에 이전 작업에 대한 내용을 기억하고 있음