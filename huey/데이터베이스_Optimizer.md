<!-- - title: 데이터베이스 옵티마이저  -->
<!-- - author: 장현희  -->
<!-- - date: 2023-01-19 12:00:00 +0800 -->

# 옵티마이저(Optimizer)

## 정의

- 쿼리 최적화(Query Optimization) 수행하는 관계형 데이터베이스의 핵심 엔진
- 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해 주며, 이를 실행계획이라 부름
- 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있음
- SQL을 실행하는 그 즉시 실행되는 것이 아니라 옵티마이저에서 실행계획을 세우는 것 부터 시작

![Untitled](https://user-images.githubusercontent.com/77145383/213431273-fd5ab60f-2c07-42cc-82e5-81d208c72ef1.png)

## 동작 방식

- **파서 (Parser)** : SQL문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱 해서 파싱 트리를 생성
    - **Parsing Tree** : SQL 문을 이루는 개별 구성요소를 분석하여 파싱 트리 생성
    - **Syntax** : 문법적 오류가 없는지 확인 (사용할 수 없는 키워드나 누락된 키워드 등)
    - **Semantic** : 의미상 오류가 없는지 확인 (존재하지 않는 테이블 또는 컬럼, 권한 문제 등)
- **옵티마이저 (Optimizer)**
    - **Query Transformer** : 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL로 변환이 가능한지 판단 및 변환
    - **Estimator** : 시스템 통계정보를 딕셔너리로부터 수집하여 SQL을 실행할 때 소요되는 총 비용을 계산
    - **Plan Generator** : Estimator를 통해 계산된 값들을 토대로 후보군이 될 실행계획 도출
    - **Row-Source Generator** : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는 코드나 프로시저 형태로 포맷팅
- **SQL 실행 엔진 (SQL Engine)** : SQL 실행


# 종류

옵티마이저는 크게 두 종류로 구분하고 있음

## 1. 규칙 기반 옵티마이저 (RBO :: Rule Based Optimizer)

### 정의

- 실행 속도가 빠른 순으로 우선 정렬 후, 우선순위가 앞서는 작업을 먼저 수행
- 오라클 8 이하의 버전의 기본 설정
- 과거에는 비용을 예측하는 능력이 충분하지 않아서 해당 방식을 선택했음
- 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스 유무와(유일, 비유일, 단일, 복합 인덱스) 종류, SQL문 에서 사용하는 연산자(=, <, <>, LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체(힙, 테이블, 클러스터 테이블 등)의 종류 등이 있다.

### 오라클 예시

아래는 Oracle의 규칙기반 옵티마이저입니다. (15가지 규칙 숫자가 낮을수록 높은 우선순위)

해당 우선순위를 이용해 효율적인 쿼리문을 작성할 수 있습니다.

| 순위 | 액세스경로 | 설명 |
| --- | --- | --- |
| 1 | Single Row By Rowid | ROWID에 의한 단일 로우 |
| 2 | Single Row By Cluster Join | 클러스터 조인에 의한 단일 로우 |
| 3 | Single Row By Hash Cluster Key whit Unique or Primary Key | 유일하거나 PK를 가진 해시 클러스터키에 의한 단일 로우 |
| 4 | Single Row By Unique or Primary Key | 유일하거나 PK에 의한 단일 로우 |
| 5 | Clustered Join | 클러스터 조인 |
| 6 | Hash Cluster Key | 해시 클러스터 키 |
| 7 | Indexed Cluster Key | 인덱스 클러스터 키 |
| 8 | Composite Index | 복합 컬럼 인덱스 |
| 9 | Single-Column Indexes | 단일 컬럼 인덱스 |
| 10 | Bounded Range Search on Indexed Columns | 인덱스가 구성된 컬럼에서 제한된 범위 검색 |
| 11 | Unbounded Range Search on Indexed Columns | 인덱스가 구성된 컬럼에서 무제한 범위 검색 |
| 12 | Sort Merge Join | 정렬-병합 조인 |
| 13 | MAX or MIN of Indexed Column | 인덱스가 구성된 열에서 MAX 또는 MIN |
| 14 | ORDER BY on Indexed Column | 인덱스가 구성된 열에서 ORDER BY |
| 15 | Full Tabel Scan | 풀 테이블 스캔 |

## 2. 비용 기반 옵티마이저 (CBO :: Cost Based Optimizer)

### 정의

- 실행 계획을 세운 뒤 비용이 최소한으로 나온 실행 계획을 수행
    - 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소유시간 또는 자원 사용량을 의미
- 최근에 많이 사용하고 있는 옵티마이저 방식
- 오라클 10 이후부터 공식적으로 비용 기반 옵티마이저만 사용 중
- 비용을 예측하기 위해서 규칙 기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보와 시스템 통계정보를 이용
- 통계정보가 없는 경우 비효율적인 실행계획을 생성할 수 있으므로, 정확한 통계정보를 유지하는 것이 중요

### 주요 통계 정보

비용 기반 옵티마이저는 실행 계획을 세울 때 통계 정보를 사용하기 때문에 해당 정보는 꾸준히 갱신되고 있는 것이 좋습니다. 통계 정보의 생성 주기 및 수행 시간을 스케줄러에 일괄적으로 등록하여 일정 주기마다 통계 정보를 수집하고 종료하도록 자동 통계 정보를 생성할 수도 있고, 사용자가 직접 수동으로 통계 정보를 생성할수도 있습니다.

- 테이블 관련 정보
    - 테이블의 전체 행의 개수
    - 테이블이 차지하고 있는 전체 블록 개수
    - 테이블의 행들이 가지고 있는 평균 길이
- 컬럼 관련 정보
    - 컬럼 값의 종류
    - 컬럼 내부 NULL값의 분포도
    - 컬럼 값의 평균 길이
    - 컬럼 내부 데이터 분포의 추정치
- 인덱스 관련 정보
    - Leaf Bolock 수 : 데이터를 보관하는 블록 수
    - Levels : 인덱스 트리의 Level 정보
    - Clustering Factor : 접근하고자 하는 데이터가 모여 있는 밀집도
- 시스템 관련 정보
    - I/O 성능 및 사용률
    - CPU 성능 및 사용률

### 비용 기반 옵티마이저의 모드

- **CHOOSE :** 현재는 잘 사용하지 않지만, SQL이 실행되는 환경에서 통계 정보를 가져올 수 있으면 비용 기반 옵티마이저로 그렇지 않다면 규칙 기반 옵티마이저로 작동시키는 모드입니다.
- **FIRST_ROWS :** 옵티마이저가 처리 결과 중 첫 건을 출력하는 데 걸리는 시간을 최소화할 수 있는 실행 계획을 세우는 모드입니다. 전체 결과집합 중 일부 로우만 Fetch하다가 멈추는 것을 전제로 가장 빠른 응답 속도를 낼 수 있는 실행 계획을 선택합니다. 사용자가 만약 끝까지 Fetch 한다면 오히려 더 많은 리소스를 시용하고 전체 수행 속도도 느려질 수 있습니다.
- **FIRST_ROWS_n :** 사용자가 처음 n개 로우만 Fetch 하는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택합니다. n으로 지정할 수 있는 값은 1, 10, 100, 1000 네 가지며, 사용자가 지정한 n개 로우 이상을 Fetch 한다면 오히려 더 많은 리소스를 사용하고 전체 수행 속도도 느려질 수 있습니다.
- **ALL_ROWS :** SQL 실행 결과 전체를 빠르게 처리하는데 최적화 된 실행 계획을 세우는 모드입니다. 마지막으로 출력될 행까지 최소한의 자원을 사용하여 최대한 빨리 가져오게 하며 오라클 10g 이후로는 이 모드가 기본값으로 설정되어 있습니다. 쿼리 최종 결과집합을 끝까지 Fetch 하는 것을 전제로, 시스템 리소스(I/0， CPU, 메모리 등)를 가장 적게 사용하는 실행계획을 선택합니다.

